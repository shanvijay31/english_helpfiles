<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<title>Language Reference - Datatypes</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<link href="../css/default.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<h1>Language Reference - Datatypes</h1>
		<p>In AutoIt there is only one datatype called a <strong>Variant</strong>.&nbsp; A 
			variant can contain numeric or string data and decides how to use the data 
			depending on the situation it is being used in.&nbsp; For example, if you try 
			and multiply two variants they will be treated as numbers, if you try and 
			concatenate (join) two variants they will be treated as strings.</p>
		<p>Some examples:</p>
		<p>&nbsp;&nbsp;&nbsp; 10 * 20 equals the <strong>number </strong>200 (<strong>*</strong>
			is used to multiply two numbers)</p>
		<p>&nbsp;&nbsp;&nbsp; 10 * "20" equals the <strong>number</strong> 200</p>
		<p>&nbsp;&nbsp;&nbsp; "10" * "20" equals the <strong>number</strong> 200</p>
		<p>&nbsp;&nbsp;&nbsp; 10 &amp; 20 equals the <strong>string</strong> "1020" (<strong>&amp;</strong>
			is used to join strings)</p>
		<p>&nbsp;</p>
		<p>If a string is used as a number, an implicit call to <b><a href="../functions/Number.htm">Number()</a></b> 
        function is done. So if it doesn't contain a valid number, it will 
			be assumed to equal 0.&nbsp; For example,
		</p>
		<p>&nbsp;&nbsp;&nbsp; 10 * "fgh" equals the number <strong>0</strong>.</p>
		<p>If a string is used as a boolean and it is&nbsp; an empty string &quot;&quot; , it will 
			be assumed to equal False (see below).&nbsp; For example,
		</p>
		<p>&nbsp;&nbsp;&nbsp; NOT "&quot; equals the Boolean <b>true</b>.</p>
		<p>&nbsp;</p>
		<h2>Numbers</h2>
		<p>Numbers can be standard decimal numbers like <strong>2</strong>, <strong>4.566</strong>, 
			and <strong>-7</strong>.&nbsp;
		</p>
		<p>Scientific notation is also supported; therefore, you could write <strong>1.5e3</strong>
			instead of <strong>1500</strong>.&nbsp;
		</p>
		<p>Integers (whole numbers) can also be represented in hexadecimal notation by 
			preceding the integer with <strong>0x</strong> as in <strong>0x409</strong> or <strong>
				0x4fff</strong> (when using hex notation only 32-bit numbers are 
			valid).&nbsp;
		</p>
		<p>&nbsp;</p>
		<h2>Strings</h2>
		<p>Strings are enclosed in double-quotes like <strong>"this"</strong>.&nbsp; If you 
			want a string to actually contain a double-quote use it twice like:</p>
		<p>&nbsp;&nbsp;&nbsp; <strong>"here is a ""double-quote"" - ok?"</strong></p>
		<p>You can also use single-quotes like <strong>'this'</strong> and <strong>'here is a ' 
				'single-quote' ' - ok?'</strong></p>
		<p>&nbsp;</p>
		<p>You can mix quote types to make for easier working and to avoid having to 
			double-up your quotes to get what you want.&nbsp; For example if you want to 
			use a lot of double-quotes in your strings then you should use single-quotes 
			for declaring them:</p>
		<p>&nbsp;&nbsp;&nbsp; <strong>'This "sentence" contains "lots" of "double-quotes" does 
				it not?'</strong></p>
		<p>is much simpler than:</p>
		<p>&nbsp;&nbsp;&nbsp; <strong>"This ""sentence"" contains ""lots"" of ""double-quotes"" 
				does it not?"</strong></p>
		<p>When evaluated, strings can have Env variables or Var variables substitution 
			according to <a href="../functions/AutoItSetOption.htm#ExpandEnvStrings">Opt()</a>
			function definition.</p>
		<p>&nbsp;</p>
		<h2>Booleans</h2>
		<p>Booleans are <b>logical</b> values. Only two Boolean values exist: <b>true</b> and
			<b>false</b>.<br>
			<br>
			They can be used in variable assignments, together with the Boolean operators<b> and</b>,
			<b>or</b> and <b>not</b>.<br>
			<br>
			Examples:<br>
			$Boolean1 = true<br>
			$Boolean2 = false<br>
			$Boolean3 = $Boolean1 AND $Boolean2<br>
			<br>
			This will result in $Boolean3 being <b>false</b><br>
			<br>
			$Boolean1 = false<br>
			$Boolean2 = not $boolean1<br>
			<br>
			This will result in $Boolean2 being <b>true</b><br>
			<br>
			<br>
			If Boolean values are used together with numbers, the following rules apply:<br>
			<br>
			A value 0 will be equal to Boolean <b>false</b><br>
			Any other number value will be equal to Boolean <b>true</b><br>
			<br>
			Example:<br>
			$Number1 = 0<br>
			$Boolean1 = true<br>
			$Boolean2 = $Number1 and $Boolean1<br>
			<br>
			This will result in $Boolean2 being <b>false</b><br>
			<br>
			<br>
			If you use arithmetics together with Boolean values (<b>which is not advisable!</b>), 
			the following rules apply:<br>
			<br>
			A Boolean true will be converted into the numeric value <b>1</b><br>
			A Boolean false will be converted into the numeric value <b>0</b><br>
			<br>
			Example:<br>
			$Boolean1 = true<br>
			$Number1 = 100<br>
			$Number2 = $Boolean1 + $Number1<br>
			<br>
			This will result in $Number2 to be the numeric value 101<br>
			<br>
			<br>
			If you use strings together with Boolean values, they will be converted as 
			follows:<br>
			<br>
			A Boolean true will be the string value <b>"True&quot;</b><br>
			A Boolean false will be the string value <b>"False&quot;</b><br>
			<br>
			Example:<br>
			$Boolean1=true<br>
			$String1="Test is: "<br>
			$String2=$String1 &amp; $Boolean1<br>
			<br>
			This will result in $String2 being the string value "Test is: True&quot;<br>
			<br>
			The other way around however is different. When you use string comparisons 
			with Boolean values, the following rules apply:<br>
			Only an empty string ("")&nbsp;will be a Boolean <b>false</b><br>
			Any other string values&nbsp;(including a string equal "0")&nbsp;will be a 
			Boolean <b>true</b><br>
			<br>
			&nbsp;</p>
		<h2>Binary</h2>
		<p>Binary type can store any byte value. they are converted in 
        hexadecimal representation when stored in a string variable.
		Example:<br>
		$bin = Binary(&quot;abc&quot;)<br>$str = String($bin)&nbsp;&nbsp;&nbsp; 
        ; &quot;0x616263&quot;</p>
<br>
		<h2>Pointer</h2>
		<p>Pointer types store a memory address which is 32bits or 64bits 
		depending on if the 32bit or 64 bit of AutoIt is used. They are converted 
		to 
        hexadecimal representation when stored in a string variable. Window 
		handles (HWnd) as returned from <a href="../functions/WinGetHandle.htm">WinGetHandle</a> are a pointer type.</p>
<p>&nbsp;</p>
		<h2>Datatypes and Ranges</h2>
		<p>The following table shows the internal variant datatypes and their 
		ranges.</p>
		<table width="100%" border="1" cellspacing="0" cellpadding="3">
			<tr bgcolor="#000066">
				<td width="12%" nowrap><font color="#ffffff"><strong>Data Sub-type</strong></font></td>
				<td width="88%"><font color="#ffffff"><strong>Range and Notes</strong></font></td>
			</tr>
			<tr>
				<td nowrap>Int32</td>
				<td>A 32bit signed integer number.</td>
			</tr>
			<tr>
				<td nowrap>Int64</td>
				<td>A 64bit signed integer number</td>
			</tr>
			<tr>
				<td nowrap>Double</td>
				<td>A double-precision floating point number.</td>
			</tr>
			<tr>
				<td nowrap>String</td>
				<td>Can contain strings of up to 2147483647 characters.</td>
			</tr>
			<tr>
				<td nowrap>Binary</td>
				<td>Binary data, can contain up to 2147483647 bytes.</td>
			</tr>
			<tr>
				<td nowrap>Pointer</td>
				<td>A memory address pointer.&nbsp; 32bit or 64bit depending on 
				the version of AutoIt used.</td>
			</tr>
		</table>
		<p>&nbsp;</p>
		<p>Some functions in AutoIt only work with 32 bit numbers (e.g. <a href="../functions/BitAND.htm">
				BitAND</a>) and are converted automatically - these functions are 
			documented where required.</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
		<p>&nbsp;</p>
	</body>
</html>
